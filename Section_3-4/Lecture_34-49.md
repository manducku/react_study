
###34. Foreword on Redux

[http://redux.js.org/](http://redux.js.org/) 이곳에서 Redux의 개발배경과 자세한 사항들을 알 수 있다. 

---
###35. What is Redux?

도서리스트 웹 어플리케이션을 생각해보자. 왼편에 책의 리스트가 있고 가운데에는 선택한 책의 디테일 정보를 보여주는 뷰가 있다.
목록중에서 하나의 아이템(책)을 선택하면 선택한 책의 디테일 정보가 가운데 표시되는 간단한 어플리케이션이다.

이 어플리케이션은 두개의 층을 가진다.
 - 데이터 : 책의 목록, 현재 선택된 책
 - 뷰 : 리스트 뷰, 리스트 아이템 뷰, 디테일 뷰

표면적으로 두개의 층이 하나의 공간에서 상호 작용하고 있는 상황이다.

---
###36. More on Redux

Redux는 이전에 설명한 두개의 층 중 데이터를 담당한다. 반대로 React는 뷰를 담당하고 있다.
 - Redux는 state container 로서 어플리케이션에 정의된 모든 데이터 모음이다
 - React는 동적으로 변하는 데이터를 표현하는 기능이다

여기까지 보면 여타 다른 js 프레임웍이랑 다를 것이 없다. 하지만 Redux는 하나의 객체에 모든 state를 담는다.
그리고 state를 변화시키는 유일한 방법은 action객체를 전달하는 것이다. 액션 객체는 무슨 일이 벌어지는 지를 묘사하하는 평범한 객체이다.
또한 액션에 의해 상태가 어떻게 변화하는 지를 지정하기 위해 Reducer를 만들어야 한다.

---
###37. Even More on Redux!

사실 이 모델을 제일 빨리 파악하고 state 구조를 디자인는 하는 방법은 어플리케이션을 만들어보는 것이다.
틴더 어플리케이션은 좋은 Redux 어플리케이션 예제 이다.

---
###38. Reducers

Reducer는 함수다. 어플리케이션의 state 일부를 리턴한다. 이게 다다.
어플리케이션은 많은 state의 모음을 가지고 있고, 이는 많은 Reducer를 가진다는 뜻이기도 하다.
35강의 도서리트스를 떠올려보자. 책의 목록 state와 현재 선택된 책 state가 있다. 이는 두개의 reducer가 있음을 뜻한다.

```{.javascript}
//Application State - Generated by reducers
{
	books: [{title: 'Harry Potter'}, {title: 'JavaScript'}], //		Books Reducer
	activeBook: {title: 'Javascript: The Good Parts'},	//		ActiveBook Reducer
}
```
키값은 원하는 대로 지정하면 된다. 리듀서에서 신경 쓸 곳은 밸류 부분이다.

```{.javascript}
// reducer_books.js

export default function () {
	return [
		{ title: 'JavaScript: The Good Parts', pages: 68},
		{ title: 'Harry Potter', pages: 101 },
		{ title: 'The Dark Tower', pages: 85 },
		{ title: 'Eloquent Ruby', pages: 2 },
	]
}
```

다음으로 Redux 내장 메서드인 combineReducers로 리듀서들을 묶어준다.
```{.javascript}
// index.js

import {combineReducers } from 'redux';
import BooksReduer from './reducer_books';


const rootReducer = combineReducers({
	// state를 매핑한다
	books: BooksReduer
});

export default rootReducer
```

---
###39. Containers - Connecting Redux to React

Container는 리액트 컴포넌트를 가리키는데, 컴포넌트 중에서도 Redux로 처리되는 state에 직접연결된 컴포넌트를 의미한다.
조금 더 상위의 위상을 가진 컴포넌트라고 생각 할 수 있다.

```{.javascript}
// book-list.js

class BookList extends Component {
	renderList() {
		return this.props.books.map((book) => {
			return (
				<li 
					// iterate 객채에는 key라는 유니크한 값을 지정해 주어야 한다. React의 규칙이다.
					// 키값을 지정해 줌으로써 빠르게 탐색할 수 있게 된다.
					key={book.title}
					className="list-group-item">{book.title}</li>
			);
		});
	}

	render() {
		return (
			<ul className="list-group col-sm-4">
				{this.renderList()}
			</ul>
		);
	}
```
아직은 Redux와 연결되지않은 일반 컴포넌트이다. 이제부터 container로 승격 시켜야 한다.
먼저 components와 동일한 위치에 containers라는 폴더를 만든다. book-list.js 파일을 containers 폴더로 옮긴다.

---
###40. Containers Continued

앞서서 BookList를 컨테이너로 승격시켰다. 그 근거를 밝히자면,
 - redux와 연결된 state(앞서 맵핑했던 books)를 관리하는 컴포넌트다.

---
###41. Implementation of a Container Class

 ```{.javascript}
 // app.js : app 컴포넌트는 container가 아니라 일반 컴포넌트다

import React, { Component } from 'react';
import BookList from '../containers/book-list';


export default class App extends Component {
  render() {
    return (
      <div>
      	<BookList />
      </div>
    );
  }
}
```

그리고 book-list.js에서 
```{.javascript}
import { connect } from 'react-redux';

class BookList extends Component {
	renderList() {
		// 사실 이부분이 제일 의아했을 것이다.
		// 우리가 상위로 받은적이 없는 books라는  props라는 값을 쓰고 있다.(app.js를 보라)
		return this.props.books.map((book) => {
			return (
				<li 
					key={book.title}
					onClick={ () => this.props.selectBook(book) }
					className="list-group-item">{book.title}</li>
			);
		});
	}

	render() {
		return (
			<ul className="list-group col-sm-4">
				{this.renderList()}
			</ul>
		);
	}
}

function mapStateToProps(state) {
	//Whatever is returned will show up as props inside of BookList
	return {
		books: state.books
	}
}
```
밑에 추가된 mapStateToProps는 이름 그대로 현재 허플리케이션의 state(38강 참조)의 books를 BookList의 props로 바꾸어주는 부분이다.
그리고 하나더 추가해 줄것이 필요하다.

```{.javascript}
export default connect(mapStateToProps)(BookList);
```
react-redux에서 import 해온 connect 메서드로 redux와 react를 연동시켜주는 역할을 한다.(36강)

---
###42. Containers and Reducers Review

데이터의 흐름을 추적한다.
 1. Reducer : reducer_books.js에서 리듀서는 데이터(배열)를 리턴한다.
 2. reducer/index.js에서 combineReducers로 books 키값에 reducer_books.js에서 export한 값이 등록된다.
 3. books는 이제 global application state가 된다.
 4. BookList 컴포넌트를 container로 분류하기 위해 먼저 react-redux의 connect 메서드를 사용한다.

---
###43. Actions and Action Creators

redux 어플리케이션에서 action의 생명주기
 1. 사용자의 활동에의해 직접적이든 간접적이든 action creator를 호출한다.
 2. action creator는 함수다. action 객체를 리턴한다.
 3. action에 정의된 type과 여타 정보를 리듀서로 전달한다.
 4. reducer는 action이 무엇인가에 따라 다른 state를 반환한다.
 5. 반한된 state는 전체 어플리케이션의 state에 반영된다.
 6. 변화된 state는 react 어플리케이션에 반영되고 변화로 인해 rerender 된다.

---
###44. Binding Action Creators

이제부터 할일은 book item을 클릭했을 때 디테일 정보를 나타내는 것이다. 우선으로 Action Creator를 만들어야 한다.
```{.javascript}
// actions/index.js

export function selectBook(book){
	console.log('A book has been selected:', book.title);
}
```
다시 BookList 컨테이너로 돌아와 selectBook action과 묶어주어야 한다.

```{.javascript}
// container/book-list.js 

import {selectBook} from '../actions/index.js';
import {bindActionCreators} from 'redux';

// code...

// Anything returned from this function will end up as props
// on the BookList container
function mapDispatchToProps(dispatch){
	// Whenever selectBook is called, the result should be passed
	// to all of our reducers
	return bindActionCreators({ selectBook: selectBook }, dispatch)
}

export default connect(mapStateToProps, mapDispatchToProps)(BookList);
```
 - 먼저 주목해야 할 부분은 dispatch이다. bindActionCreators와 함께 dispatch가 하는 일은 action을 받아서 reducer들에게 뿌리는 역할을 한다.
 - mapStateToProps에서 state.books를 props.books로 전달해 주었던 것 처럼 mapDispatchToProps로 props.selectBook으로 action을 호출할 수 있게 됐다.

---
###45. Creating an Action

실제적인 action을 만들 차례다. 
```{javascript}
// containers/book-list.js

class BookList extends Component {
	renderList() {
		return this.props.books.map((book) => {
			return (
				<li 
					key={book.title}
					onClick={ () => this.props.selectBook(book) }
					className="list-group-item">{book.title}</li>
			);
		});
	}
	
	// code...
}
```
우선 이벤트 핸들러로 selectBook action creator를 등록한다.
이제 브라우저에서 콘솔을 키고 목록들을 클릭해보면(에러가 뜨긴하지만) 선택된 책의 제목들이 보인다.

actions/index.js로 돌아가서
```{.javascript}
export function selectBook(book){
	// selectBook is an ActionCreator, it needs to return an action
	// an object with a type property
	return {
		type: 'BOOK_SELECTED',
		payload: book
	}
}
```
일반적으로 return되는 action 객체는 type과 payload라는 두가지 밸류를 가진다. type은 필수이지만 payload는 그렇지 않다.
또한 type은 언제나 대문자 문자열로 쓰인다.

---
###46. Consuming Actions in Reducers

reducers폴더에 reducer_active_book.js파일을 만든다.
```{javascript}
// 여기에 쓰인 state는 전체 어플리케이션의 state를 나타내는 것이 아니라 리듀서가 맵핑된 state를 나타낸다.
export default function(state=null, action) {
	switch(action.type){
		case 'BOOK_SELECTED':
			return action.payload
		default:
			return state
	}	
}
```
인자에 state = null부분은 ES6에서 새로 추가된 문법으로 state를 지정해 주지 않으면 초기값으로 null을 넣겠다는 뜻이다.

```{.javascript}
// reducers/index.js 

..
import ActiveBook from './reducer_active_book';

const rootReducer = combineReducers({
	books: BooksReduer,
	activeBook: ActiveBook,
});
```

---
###47. Consuming Actions in Reducers Continued

book-detail.js를 containers폴더에 만들어준다. 계획대로 activeBook의 디테일 정보를 보여주기 위함이다.
```{.javascript}
import React, { Component } from 'react';
import { connect } from 'react-redux';


class BookDetail extends Component {
	render() {
		return (
			<div>
				<h3>Details for:</h3>
				<div>Title: { this.props.book.title }</div>	
				<div>Pages: {this.props.book.pages }</div>
			</div>
		);
	}
}


function mapStateToProps(state) {
	return {
		book: state.activeBook,
	}
}

export default connect(mapStateToProps)(BookDetail);
```
reducer에서 state.activeBook을 설정해 주었고 그것을 다시 book에 맵핑 시켜 this.props.book으로 사용할 수 있게 됐다.
이제 app.js에서 BookDetail을 추가하면 된다. 

---
###48. Conditional Rendering
```{.javascript}
class BookDetail extends Component {
	render() {
		if(!this.props.book){
			return <div>Select a book to get started.</div>
		}
		return (
			<div>
				<h3>Details for:</h3>
				<div>Title: { this.props.book.title }</div>	
				<div>Pages: {this.props.book.pages }</div>
			</div>
		);
	}
}

// code...
```
이전 강의에서 애플리케이션을 구동시키면 콘솔창에서 에러를 볼 수 있다.
"Uncaught TypeError: Cannot read property 'title' of null"
처음 activeBook은 아무것도 없는  null이므로 title프로퍼티를 가질 수 없고 이로인해 오류가 발생한 것이다.
위처럼 분기처리를 해주면 정상적으로 작동한다.

---
###49. Reducers and Actions Review

모든 강의를 통틀어 제일 중요한 부분은 redux에서 어떻게 어플리케이션 state를 다루는지에 관한 것이다.
 1. state는 하나의 순수한 javascript 객체이다.
 2. 컴포넌트가 가지는 state는 redux가 다루는 어플리케이션 state와 전혀 다른 것이다.
 3. 어플리케이션 state는 Reducer에 의해 만들어진다.
 4. reducer들은 combineReducers로 묶이고 application state에 맵핑 된다.
 5. action에 의해서 state값의 변형을 가져온다.